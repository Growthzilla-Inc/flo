// Generated by CoffeeScript 2.6.1
(function() {
  // **[flo](https://github.com/FLOChip/flo)** is an redis powered node.js autocompleter inspired by [soulmate](https://github.com/seatgeek/soulmate).
  // You can check out some examples [here](https://github.com/FLOChip/flo/tree/master/examples).
  var Connection, Helper, _, async, connectToRedis;

  _ = require("underscore");

  async = require("async");

  // Sets up a new Redis Connection.

  // options - Optional Hash of options.

  // * `redis`       - An existing redis connection to use.
  // * `host`        - String Redis host.  (Default: Redis' default)
  // * `port`        - Integer Redis port.  (Default: Redis' default)
  // * `password`    - String Redis password.
  // * `namespace`   - String namespace prefix for Redis keys.
  //               (Default: flo).
  // * `mincomplete` - Minimum completion of keys required for auto completion.
  //               (Default: 1)
  // * `database`    - Integer of the Redis database to select.

  // Returns a Connection instance.
  exports.connect = function(options) {
    return new exports.Connection(options || {});
  };

  // Handles the connection to the Redis server.
  Connection = class Connection {
    constructor(options) {
      this.helper = new Helper();
      this.redis = options.redis || connectToRedis(options);
      this.namespace = options.namespace || 'flo';
      this.mincomplete = options.mincomplete || 1;
      this.searchCache = options.searchCache || 600;
      if (options.database != null) {
        this.redis.select(options.database);
      }
    }

    // Public: Get all prefixes for a phrase

    // * `phrase` - the phrase that needs to be parsed into many prefixes

    // Returns an array of unique prefixes for the phrase
    prefixes_for_phrase(phrase) {
      var words;
      words = this.helper.normalize(phrase).split(' ');
      return _.uniq(_.flatten(_.map(words, (w) => {
        var ref, ref1;
        return _.map((function() {
          var results1 = [];
          for (var i = ref = this.mincomplete - 1, ref1 = w.length - 1; ref <= ref1 ? i <= ref1 : i >= ref1; ref <= ref1 ? i++ : i--){ results1.push(i); }
          return results1;
        }).apply(this), function(l) {
          return w.slice(0, +l + 1 || 9e9);
        });
      })));
    }

    // Public: Search for a term

    // * `types` - types of term that you are looking for (Array of String)
    // * `phrase` - the phrase or phrases you want to be autocompleted
    // * `limit` - the count of the number you want to return (optional, default: 5)
    // * `callback(err, result)` - err is the error and results is the results
    search_term(types, phrase, ...args) {
      var callback, limit;
      if (typeof args[0] === 'number') {
        limit = args[0];
      } else {
        limit = 5;
      }
      callback = args[args.length - 1];
      return async.map(types, (type, callb) => {
        var cachekey, words;
        words = _.uniq(this.helper.normalize(phrase).split(' ')).sort();
        // for caching purpose
        cachekey = this.key(type, "cache", words.join('|'));
        return async.waterfall([
          ((cb) => {
            return this.redis.exists(cachekey,
          cb);
          }),
          ((exists,
          cb) => {
            var interkeys;
            if (!exists) {
              interkeys = _.map(words,
          (w) => {
                return this.key(type,
          "index",
          w);
              });
              return this.redis.zinterstore(cachekey,
          interkeys.length,
          ...interkeys,
          (err,
          count) => {
                return this.redis.expire(cachekey,
          this.searchCache,
          function() { // expire after defined number of seconds or 10 minutes
                  return cb();
                });
              });
            } else {
              return cb();
            }
          }),
          ((cb) => {
            return this.redis.zrevrange(cachekey,
          0,
          limit - 1,
          (err,
          ids) => {
              if (ids.length > 0) {
                return this.redis.hmget(this.key(type,
          "data"),
          ...ids,
          cb);
              } else {
                return cb(null,
          []);
              }
            });
          })
        ], function(err, results) {
          var data;
          data = {};
          data[type] = results;
          return callb(err, data);
        });
      }, function(err, results) {
        results = _.extend(...results);
        results.term = phrase;
        return callback(err, results);
      });
    }

    // Public: Add a new term

    // * `type`     - the type of data of this term (String)
    // * `id`       - unique identifier(within the specific type)
    // * `term`     - the phrase you wish to provide completions for
    // * `score`    - user specified ranking metric (redis will order things lexicographically for items with the same score)
    // * `data`     - container for metadata that you would like to return when this item is matched (optional)
    // * `callback` - callback to be run (optional)

    // Returns nothing.
    add_term(type, id, term, score, ...args) {
      var callback, data;
      if (typeof args[0] !== 'function') {
        data = args[0];
        callback = args[args.length - 1];
      } else if (typeof args[0] === 'function') {
        callback = args[0];
      }
      // store the data in parallel
      return async.parallel([
        ((callb) => {
          return this.redis.hset(this.key(type,
        "data"),
        id,
        JSON.stringify({
            id: id,
            term: term,
            score: score,
            data: data || []
          },
        function() {
            return callb();
          }));
        }),
        ((callb) => {
          return async.forEach(this.prefixes_for_phrase(term),
        ((w,
        cb) => {
            return this.redis.zadd(this.key(type,
        "index",
        w),
        score,
        id, // sorted set
        function() {
              return cb();
            });
          }),
        function() {
            return callb();
          });
        }),
        ((callb) => {
          var key;
          key = this.key(type,
        this.helper.normalize(term));
          // do we already have this term?
          return this.redis.get(key,
        (err,
        result) => {
            var arr;
            if (err) {
              return callb(err);
            }
            if (result) {
              // append to existing ids (without duplicates)
              arr = JSON.parse(result);
              arr.push(id);
              arr = _.uniq(arr);
            } else {
              arr = [id];
            }
            // store the id
            return this.redis.set(key,
        JSON.stringify(arr),
        callb);
          });
        })
      ], function() {
        if (callback != null) {
          return callback();
        }
      });
    }

    // Public: Remove a term

    // * `type`     - the type of data of this term (String)
    // * `id`       - unique identifier (within the specific type)
    // * `callback(err)` - callback to be run (optional)

    // Returns nothing.
    remove_term(type, id, callback) {
      //get the term
      return this.redis.hget(this.key(type, "data"), id, (err, result) => {
        var term;
        if (err) {
          return callback(err);
        }
        if (result === null) {
          return callback(new Error("Invalid term id"));
        }
        term = JSON.parse(result).term;
        // remove
        return async.parallel([
          ((callb) => {
            return this.redis.hdel(this.key(type,
          "data"),
          id,
          callb);
          }),
          ((callb) => {
            return async.forEach(this.prefixes_for_phrase(term),
          ((w,
          cb) => {
              return this.redis.zrem(this.key(type,
          "index",
          w),
          id,
          function() {
                return cb();
              });
            }),
          callb);
          }),
          ((callb) => {
            var key;
            key = this.key(type,
          this.helper.normalize(term));
            return this.redis.get(key,
          (err,
          result) => {
              var arr;
              if (err) {
                return callb(err);
              }
              if (result === null) {
                return cb(new Error("Couldn't delete " + id(+". No such entry.")));
              }
              arr = JSON.parse(result);
              if (arr.toString() === [id].toString()) {
                // delete it
                return this.redis.del(key,
          callb);
              }
              return this.redis.set(key,
          JSON.stringify(_.without(arr,
          id)),
          callb);
            });
          })
        ], function(err) {
          if (callback != null) {
            return callback(err);
          }
        });
      });
    }

    // Public: Returns an array of IDs for a term

      // * 'type'    - the type of data for this term
    // * 'term'    - the term to find the unique identifiers for
    // * 'callback(err, result)' - result is the ID for the term

      // Returns nothing.
    get_ids(type, term, callback) {
      return this.redis.get(this.key(type, this.helper.normalize(term)), function(err, result) {
        var arr;
        if (err) {
          return callback(err);
        }
        arr = JSON.parse(result);
        if (arr === null) {
          return callback(null, []);
        }
        return callback(null, arr);
      });
    }

    // Public: Returns the data for an ID

      // * 'type'    - the type of data for this term
    // * `id`       - unique identifier (within the specific type)
    // * 'callback(err, result)' - result is the data

      // Returns nothing.
    get_data(type, id, callback) {
      return this.redis.hget(this.key(type, "data"), id, function(err, result) {
        if (err) {
          return callback(err);
        }
        return callback(null, JSON.parse(result));
      });
    }

    // Public: Get the redis instance

    // Returns the redis instance.
    redis() {
      return this.redis;
    }

    // Public: Quits the connection to the Redis server.

    // Returns nothing.
    end() {
      return this.redis.quit();
    }

    // Builds a namespaced Redis key with the given arguments.

    // * `type` - Type of the param
    // * `args` - Array of Strings.

    // Returns an assembled String key.
    key(...args) {
      args.unshift(this.namespace);
      return args.join(":");
    }

  };

  Helper = class Helper {
    // Public: Normalize a term to remove all other characters than a-z and 0-9.

    // * `term` - the term to be normalized

    // Returns a normalized term.
    normalize(term) {
      return this.strip(this.gsub(term.toLowerCase(), /[^a-z0-9 ]/i, ''));
    }

    // Public: This function partially simulates the Ruby's String gsub method.

    // * `source` - the source string
    // * `pattern` - the Regex pattern
    // * `replacement` - the replacement text

    // Example:

    //     gsub("-abc-abc-", /[^a-z0-9 ]/i, '')  # returns "abcabc"
    //     gsub("-abc-abc-", /[^a-z0-9 ]/i, '*') # returns "*abc*abc*"

    // Returns the modified string.
    gsub(source, pattern, replacement) {
      var match, result;
      if (!((pattern != null) && (replacement != null))) {
        return source;
      }
      result = '';
      while (source.length > 0) {
        if ((match = source.match(pattern))) {
          result += source.slice(0, match.index);
          result += replacement;
          source = source.slice(match.index + match[0].length);
        } else {
          result += source;
          source = '';
        }
      }
      return result;
    }

    // Public: Strip out leading and trailing whitespaces.

    // * `source` - string to be stripped

    // Returns a copy of str with leading and trailing whitespace removed.
    strip(source) {
      return source.replace(/^\s+/, '').replace(/\s+$/, '');
    }

  };

  connectToRedis = function(options) {
    var redis;
    redis = require('redis').createClient(options.port, options.host);
    if (options.password != null) {
      redis.auth(options.password);
    }
    return redis;
  };

  exports.Helper = new Helper();

  exports.Connection = Connection;

}).call(this);
